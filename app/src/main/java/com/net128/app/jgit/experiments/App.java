/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.net128.app.jgit.experiments;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.treewalk.TreeWalk;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.time.Instant;

public class App {

    public static void main(String[] args) throws IOException, IllegalStateException, GitAPIException, URISyntaxException, InterruptedException {
        new App().run();
    }

    public void run() throws GitAPIException, IOException, URISyntaxException, InterruptedException {
        final var gitDirectory = new File(System.getProperty("java.io.tmpdir"), "JGitTestRepository");
        final var csvDest = new File(gitDirectory,"csv");
        ResourceUtils.deleteDirectory(gitDirectory);
        try (var git = Git.init().setDirectory(gitDirectory).call()) {
            System.out.println("Created repository: " + git.getRepository().getDirectory());

            delimiter();
            System.out.println("Copying resources from classpath: /csv");
            ResourceUtils.copyResources("/csv",csvDest);
            git.add().addFilepattern(".").call();
            git.commit().setMessage("Initial commit").call();

            var version = -1;
            git.tag().setName("Version-"+ ++version).setForceUpdate(true).call();

            var initialCommitId = git.getRepository().resolve(Constants.HEAD);

            replaceCsvAndCommit(git,"/csv_mod/CITY.csv", csvDest, "Version-"+ ++version);
            replaceCsvAndCommit(git,"/csv_mod/COUNTRY_CODES.csv", csvDest, "Version-"+ ++version);
            replaceCsvAndCommit(git,"/csv_mod2/COUNTRY_CODES.csv", csvDest);

            replaceCsvAndCommit(git,"/csv_mod2/CITY.csv", csvDest, "Version-"+ ++version);
            git.tag().setName("Version-2").setForceUpdate(true).call();

            Thread.sleep(2000);
            git.checkout().setName(initialCommitId.getName()).addPath(".").call();
            git.add().addFilepattern(".").call();
            git.commit().setMessage("Reverted to initial version").call();
            git.tag().setName("Version-3").setForceUpdate(true).call();

            delimiter();
            showTagCommits(git);
            delimiter();

            processFiles(git, "HEAD",(f) -> showCommits(git, f));
        }
    }

    private void replaceCsvAndCommit(Git git, String csv, File destDir, String tag) throws GitAPIException, IOException, URISyntaxException, InterruptedException {
        replaceCsvAndCommit(git, csv, destDir);
        System.out.println("Setting tag: "+tag);
        git.tag().setName(tag).setForceUpdate(true).call();
    }

    private void replaceCsvAndCommit(Git git, String csv, File destDir) throws GitAPIException, IOException, URISyntaxException, InterruptedException {
        var destName = csv.substring(csv.lastIndexOf("/")+1);
        var destFile =  new File(destDir, destName);
        System.out.println("Committing change to: "+destFile);
        ResourceUtils.copyResources(csv, destFile);

        git.add().addFilepattern(".").call();
        Thread.sleep(557);
        git.commit().setMessage("Modified "+destName).call();
    }

    private void showCommits(Git git, String filePath) {
        System.out.println("Commits: "+filePath);
        try {
            var logCommand = git.log()
                .add(git.getRepository().resolve(Constants.HEAD))
                .addPath(filePath);

            for (var revCommit : logCommand.call()) {
                System.out.println(commitInfo(revCommit));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void showTagCommits(Git git) throws IOException, GitAPIException {
        var repository = git.getRepository();
        System.out.print("Tag Commits");
        var call = git.tagList().call();
        for (Ref ref : call) {
            System.out.println("\n    Tag: " + ref.getName() + " " + ref.getObjectId().getName());

            var peeledRef = git.getRepository().getRefDatabase().peel(ref);

            ObjectId commitId;
            if(peeledRef.getPeeledObjectId() != null) {
                commitId = peeledRef.getPeeledObjectId();
            } else {
                commitId = ref.getObjectId();
            }

            try (RevWalk revWalk = new RevWalk(repository)) {
                var commit = revWalk.parseCommit(commitId);
                System.out.println("    "+commitInfo(commit));
            }
        }
    }

    private void processFiles(Git git, String ref, Callable callable) throws IOException {
        System.out.println("Files from: "+ref);
        var repository = git.getRepository();
        var head = repository.getRefDatabase().findRef(ref);
        var walk = new RevWalk(repository);

        var commit = walk.parseCommit(head.getObjectId());
        var tree = commit.getTree();

        var treeWalk = new TreeWalk(git.getRepository());
        treeWalk.addTree(tree);
        treeWalk.setRecursive(false);
        while (treeWalk.next()) {
            if (treeWalk.isSubtree()) {
                treeWalk.enterSubtree();
            } else {
                if(callable==null) System.out.println(treeWalk.getPathString());
                else callable.call(treeWalk.getPathString());
            }
        }
    }

    private String commitInfo(RevCommit revCommit) {
        return "    "
            + Instant.ofEpochMilli(revCommit.getCommitTime()*1000L).toString()
            + ": "+revCommit.getId();
    }

    private void delimiter() {
        System.out.println("\n------------------------------------------------\n");
    }

    public interface Callable {
        void call(String input);
    }
}